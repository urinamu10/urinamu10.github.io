---
title: "(35일차) pandas 1,2강"
date: 2025-12-10 20:00:00 +0900
categories: [부트캠프]
tags: [python, 통계]
---



## 👟 **TIL (Today I Learend)**

1. 코드카타 (SQL)

2. Pands 1,2 강

## 🚩 코드카타 (SQL)

### 91. Confirmation Rate  (확인률)

---

 출처 - [Confirmation Rate - LeetCode](https://leetcode.com/problems/confirmation-rate/)

- 테이블 설명

![alt text](/assets/img/image.png)

- 문제

<aside>

사용자의 **확인률**은 메시지 수와 요청된 확인 메시지 총 수로 나눈 값입니다. 

확인 메시지를 요청하지 않은 사용자의 확인률은 0 입니다. 

확인률을 **소수점 두** 자리로 반올림하세요

결과 형식은 아래와 같습니다.

</aside>

- 결과 예시

![alt text](/assets/img/image-1.png)

- 풀이 로직

1. 가장 먼저 사용자의 확인율을 구하는 방법은 아래와 같습니다.

> (메시지 수 / 요청된 확인 메시지 수)
> 

```sql
COUNT(case when action = 'confirmed' then user_id end) /
Count(b.user_id) as 'confirmation_rate'
```

2. 그리고 확인 메시지를 요청하지않은 사용자는 `0`으로 처리해야하므로
    
    즉, `left join`으로 `null`값을 만들고  `0`으로 치환해야합니다.
    

> Coalesce() 또는 IFNULL()
> 

3. 확인률을 소수점 두 자리로 반  올림합니다

> ROUND( ‘’ , 2)
> 

`signups` 테이블과 `confirmations` 를 `LEFT JOIN`으로 결합하고 

유저 아이디별 확인률을 계산한후 `NULL`은 `0`으로 치환 , 소수점 2번째 자리로 반올림하면?

- 풀이 코드

```sql
select a.user_id ,
       round(coalesce(count(case when b.action = 'confirmed' then b.user_id end) / 
       COUNT(b.user_id),0), 2) as 'confirmation_rate' 
from signups a
left join confirmations b
    on a.user_id = b.user_id
group by a.user_id 
```

### **92. Average Selling Price (평균 판매 가격)**

---

출처 -https://leetcode.com/problems/average-selling-price/

- 테이블

![alt text](/assets/img/image-2.png)

- 문제

<aside>

각 제품의 평균 판매 가격을 찾는 쿼리문을 작성해주세요

결과는 소수점 2자리로 반올림 해야합니다.

판매된 단위가 전혀 없는 제품이라면 판매 가격은 0으로 가정합니다 

</aside>

- 풀이

`prices` 테이블은 제품ID와 판매시작,끝 날짜, 가격 컬럼이 있고

`unitsSold` 테이블은 제품ID와 판매 된 날짜, 판매 수량을 담고 있습니다

1. 문제에서 정의한 평균 가격은 (제품의 총 판매액 / 제품의 총 판매수량) 입니다

> sum(units*price) / sum(units)
> 

2. 그리고 소수점 2자리로 반올림

> round 함수
> 

3. 판매된 단위가 전혀 없는 제품이라면 평균 판매 가격은 0으로 지정
    
    즉, `left join`으로 결합하여 `null`인 값은 `0`으로 치환해야한다는 의미입니다
    

> coalesce() 또는 ifnull()
> 

4. 또한 판매 된 날짜가 판매시작,끝 날짜 사이에 있어야하므로 `between` 함수를 사용합니다.

> purchase_date `between` start_date `and` end_date
> 

이를 한번에 합치게 되면

- 코드

```sql
select p.product_id,
       coalesce(round(sum(u.units*p.price) / sum(u.units),2),0) as 'average_price'
from prices p
left join UnitsSold u
	on p.product_id = u.product_id
	and (u.purchase_date between p.start_date and p.end_date)
group by p.product_id
```

---

## 🚩 pandas 1,2강

---

오늘부터 배우는 pandas 심화 세션에서는 저번 프로젝트직전에 배웠던 기초적인 내용과 새롭게 배울 내용들이 포함되어 있었습니다.

pandas는 배워도 배워도 새롭다는 느낌이 듭니다 메서드나 함수등 기능들이 굉장히 많아요

다행인 점은 직관적이기 때문에 한번만 익혀두면 오랜시간 능숙하게 사용할 수 있다고 생각합니다.

튜터님께선 모든 기능을 외우기보단 핵심적인 기능들을 내가 어떻게 사용할지 나만의 스타일대로 기억하는게 더 도움이 된다고 말하셨기때문에 각 기능들이 왜 필요하고 어떨 때 사용하는지를 기억합시다!!

### Series와 DataFrame의 구조 이해

---

- https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf

가장 기초적인 내용부터 살펴보면

- **Series** : 인덱스를 가진 1차원의 배열로, 한열 또는 한 행의 데이터처럼 다룰 수 있습니다.
- **DataFrame** : 여러개의 series가 열 단위로 모여 인덱스를 공유하는 2차원의 표 형태의 데이터 구조입니다.
- **NaN** : 수치 연산에서 결측값을 나타내는 특별한 부동소수점 값입니다.
- **Null** : 데이터베이스나 프로그래밍에서 값이 없음을 나타내는 일반적인 개념입니다.

### DataFrame 의 기능들

---

직접 데이터 프레임을 만들고 그 속에서 기능들을 실행시켜보겠습니다.

- 딕셔너리 형태의 데이터 프레임 만들기

```python
import pandas as pd

df = pd.DataFrame(
        {"a" : [4 ,5, 6],
        "b" : [7, 8, 9],
        "c" : [10, 11, 12]},
        index = [1, 2, 3])
        
print(df)
```

![alt text](/assets/img/image-3.png)

**키는 컬럼 값은 행**으로 이루어진 딕셔너리 형태의 데이터 프레임으로 index 옵션값에 인덱스를 넣어줄 수 있습니다.

- 메서드 (loc)  / 위치 찾기

```python
df.loc[3, 'a']
```

‘a’ 컬럼의 3번째 인덱스는 6 이 될것입니다.

- 두개 이상의 위치 찾기

```python
df.loc[[1,3], ['a', 'b']]
```

만약 찾고자하는 인덱스와 컬럼이 두개 이상일 때는 리스트(대괄호)를 사용해 모든 값을 넣어 줄 수 있습니다.

인덱스는 1, 3 컬럼은 ‘a’ , ‘b’  라면?

![alt text](/assets/img/image-4.png)

- 리스트 형태의 데이터 프레임 만들기

```python
df = pd.DataFrame(
        [[4, 7, 10],
        [5, 8, 11],
        [6, 9, 12]],
        index=[1, 2, 3],
        columns=['a', 'b', 'c'])
df
```

이번엔 딕셔너리 형태가 아닌 리스트 형태의 데이터 프레임을 만들어보겠습니다.

키 값을 컬럼으로 사용했던 딕셔너리와 달리 직접 `colums` 옵션에 [`‘a’ , ‘b’,  ‘c’`] 를 넣어주면 

동일한 데이터 프레임을 만들 수 있습니다.

 

![alt text](/assets/img/image-5.png)

- 멀티 인덱스 (`’n’ , ‘v’`) 데이터 프레임 만들기

```python
import numpy as np
df = pd.DataFrame(
        {"a" : [4 ,5, 6, 6, np.nan],
        "b" : [7, 8, np.nan, 9, 9],
        "c" : [10, 11, 12, np.nan, 12]},
        index = pd.MultiIndex.from_tuples(
        [('d',1),('d',2),('e',2),('e',3),('e',4)],
        names=['n','v']))
df
```

> 멀티 인덱스(MultiIndex)란 무엇인가요?
> 

**멀티 인덱스**는 Pandas 데이터프레임에서 **행(Row)이나 열(Column)에 여러 계층(Level)의 레이블(Label)을 부여**하는 방식입니다. 이름 그대로 '다중 인덱스'라고 부릅니다.

일반적인 데이터프레임은 행을 구분하는 인덱스(/assets/img/ndex)가 1개만 있지만, 멀티 인덱스를 사용하면 **계층적인 구조**를 만들 수 있습니다.

멀티 인덱스를 사용하는 이유는 계층적 구조화를 하기 위해서입니다.

현실의 데이터들은 단순하지 않고 복잡한 계층을 가집니다 

예를 들어 성적표에는 **가장 상위 계층에 학년이 있고 (1학년, 2학년 등등)**

**그 다음 계층엔 반이 있고 (1반, 2반….) 마지막엔 학생 이름이 있는 테이블**이 생각납니다.

멀티인덱스를 사용하면 이런 여러가지 계층을 하나의 인덱스로 깔끔하게 표현하고 특정 계층 (예: 2학년 전체) 만 슬라이싱하여 조회할 수 있습니다.

![alt text](/assets/img/image-6.png)

- 만약 d 그룹만 보고싶다면?

```python
df.loc['d']
```

![alt text](/assets/img/image-7.png)

이런식으로 d그룹의 행들을 깔끔하게 조회할 수 있습니다.

### 비교 연산자와 논리 연산자

---

매일 SQL코드를 풀면서 만난 조건문의 개념과 동일합니다. 

(and, or ,not, any, all) 등등

위에서 사용한 멀티 인덱스 데이터프레임을 기반으로 조건을 걸어보겠습니다.

- c 컬럼값이 7보다 큰 행만 남기기

```python
df[df['c'] > 7]
```

![alt text](/assets/img/image-8.png)

> df안에 df를 한번 더 사용하는 이유
> 

pandas의 기능 중 하나인 불리언 인덱싱(Boolean indexing) 문법으로 이중 필터링 이라고 생각하면 좋습니다.

- 1단계:  먼저 안쪽의 계산식인 `df[’c’] > 7`에 대해 b 값이 7인지 아닌지 확인하고 그 결과를 `True/False` 로 이루어진 리스트(Series) 형태로 반환합니다.

- 2단계 : 그리고 바깥쪽 `df`는 이 값들 중 `True`인 행만 남기고 `False`라고 표시된 행은 버립니다.

마치 마스크에 구멍을 뚫어 보는 것과 같습니다!

- 중복된 행을 없애고 첫번째 행만 남기기

```python
df = df.drop_duplicats(keep='first')
```

![alt text](/assets/img/image-9.png)

메서드는 모든 컬럼을 기준으로 내용이 **‘완전히’** 동일한 행이 있다면 제거합니다

그리고 옵션(keep)은 여러 중복행중에서 어떤 값을 살릴지를 결정합니다 

- `keep=’first’` : 첫번째 행
- `keep=‘last` : 마지막 행
- `keep= False` : 중복되는 모든행을 제거

 이는 데이터 전처리 과정에서 중요한 기능중 하나였습니다!

- `‘a’` 컬럼에서 값이 `5`인 항목이 있는지 `Boolean`으로 반환

```python
df['a'].isin([5])
```

![alt text](/assets/img/image-10.png)

> 왜 `isin` 메서드안에 대괄호로?
> 

`isin` 메서드는 리스트 형태의 입력을 요구하기 때문입니다.

메서드는 안의 값이 참인지 거짓인지를 분별하는 기능을하는데 이는 기본적으로 리스트 목록을 요구하도록 설계되어있습니다 단일값 `5`만 넣어도 `5`를 넣은 목록을 넘겨주는것과 같습니다.

- `‘a’`가 컬럼이 가진 결측치는 총 몇행인가?

```python
df['a'].isnull().sum()
```

- `sum()`

특정 컬럼에 있는 모든 숫자의 합계를 계산합니다.  

(1, 2, 3)이라면 6이 계산되지만 `isnull()` 메서드 뒤에서 사용하면 `True`값이 1개 있기때문에 1만 계산됩니다.

- notnull / 데이터프레임에서 결측치가 없는 모든행

```python
pd.notnull(df)
```

![alt text](/assets/img/image-15.png)

결측치가 있는 행은 False로 없는 행은 True로 표현되는 `notnull` 메서드입니다.

- 역시나 sum()으로 개수를 집계할 수 있습니다.

```python
df.notnull().sum()
```

![alt text](/assets/img/image-16.png)

- 두가지 이상의 조건은?

```python
df[(df['b'] == 7) | (df['a'] == 5)]
```

![alt text](/assets/img/image-17.png)

만약 두개 이상의 조건이 필요할땐 한가지의 조건 다음에 **&(AND) ,  | (OR)** 등 논리 연산자를 이용해 다중조건을 걸어줄 수 있습니다.

- DataFrame에서 전체 행의 50%를 임의로 랜덤 샘플링
  
```python
df.sample(frac=0.5)
```

![alt text](/assets/img/image-18.png)

`sample` 메서드를 사용하면 임의의 표본(샘플)을 하나 만들어줍니다

저희가 직접만든 데이터 프레임에서 `frac=0.5` (50%) 만큼만 보여줘! 라고 말하는것과 동일합니다. 

> `fraq` 옵션의 의미는?
전체 행의 비율을 0부터 1사이에 값으로 지정할 수 있는 옵션입니다 
`df.sample(frac=0.1)`은 전체 행의 10%를 추출
> 

또는 이런 방법도 가능합니다.

- 퍼센테이지가 아닌 특정 개수만큼 가져올 때

```python
df.sample(n=5)
```

![alt text](/assets/img/image-19.png)

`sample` 메서드 내부 옵션에 `n =5`는 전체 행중에서 랜덤으로 5개만 가져와줘 라는 의미로 

데이터 프레임의 행이 수십만개 이상일 때, 데이터를 모두 출력하지않고 무작위로 10만 추출할 수 있는 코드로써 구조나 이상유무를 빠르게 파악 할 수 있습니다.

- DataFrame에서 마지막 두 행을 정수 위치 기반으로 선택하기

```python
df.iloc[-2:]
```

![alt text](/assets/img/image-20.png)

`df.iloc[-2:]`는 데이터프레임의 **가장 마지막 두 행**을 선택하여 새로운 데이터프레임으로 반환합니다.

- `iloc` (/assets/img/ndex Location) 메서드는 행과 열을 정수위치를 사용하여 선택하는데 사용되는 접근자입니다.
- `loc`가 인덱스 레이블을 사용했던것과는 다르게 `iloc`는 파이썬 리스트처럼 0부터 시작하는 숫자 인덱스를 사용합니다

- 특정 컬럼을 기준으로 가장 큰값을 가진 행을 반환하기

```python
df.nlargest(1, 'a')
```

![alt text](/assets/img/image-21.png)

1. `nlargest` 메서드는 (반환할 행의 개수, 컬럼명)의 기본구조로 가장 큰 값을 가진 행을 반환합니다.

1. `nsmallest` 메서드는 가장 작은 값을 가진 행을 반환하겠죠?

> all, any 기능 알아보기
> 

- all, any 기능을 알아보기 위해 만든 데이터프레임

```python
df["d"] = True
df["e"] = False
df["f"] = True
df.loc[1, "f"] = False
df
```

![alt text](/assets/img/image-22.png)

`d, e` 컬럼을 만들고 `d`에는 모두 `True`를 `e`에는 `False`를 `f`에는 하나만 `False`를 생성합니다.

- 모두 True 일때만 True로 출력

```python
df.all()
```

![alt text](/assets/img/image-23.png)

- 하나라도 True 라면 True로 출력

```python
df.any()
```

- 결측치 여부를 `boolean`으로 구하기

```python
df.notnull()
```

![alt text](/assets/img/image-24.png)

- notnull로 결측치 여부확인, 하나라도 있는 컬럼 찾기

```python
df.notnull().all()
```

### 컬럼단위 서브셋 추출

---

- `loc` : 라벨(인덱스 이름) 기반으로 행과 열을 선택
- `iloc` : 정수위치 (숫자 인덱스) 기반으로 행과 열을 선택

- ‘iris’ 데이터셋을 seaborn 메서드로 불러오기

```python
# pandas, seaborn을 불러왔다는 가정하에

df = sns.load_dataset('iris')
df.head()
```

![alt text](/assets/img/image-25.png)

- 데이터 프레임에서 특정 컬럼들만 불러오기

```python
columns = ['sepal_width', 'sepal_length', 'species']
df[columns].head()
```

![alt text](/assets/img/image-26.png)

- 특정 위치의 인덱스와 컬럼값 조회하기

```python
df.loc[2:5, 'sepal_width' : 'petal_width']
```

![alt text](/assets/img/image-27.png)

2번부터 5번까지의 인덱스에서 

컬럼명 `‘sepal_width’`에서 `‘petal_width’`까지의 행을 가져오기 

- DataFrame에서 앞쪽 3행과 2번째, 4번재 열만 선택하기

```python
df.iloc[:3, [1,3]]
```

![alt text](/assets/img/image-28.png)

`:3` 은 앞에서 3번째 , `[1,3]` 은 2번째와 4번째 컬럼을 가져오기 

### 실습 문제

---

**조건에 맞는 행과 열만 선택하여 상위 5개만 확인하는 코드를 만드시오**

> 조건 1) ‘sepal_length’ 컬럼 값이 5보다 큰 행만 선택
> 

> 조건 2) 선택된 행에서 ‘sepal_length’와 ‘sepal_width’ 두개의 열만 선택
> 

> 조건 3) 결과의 상위 5개 행만 출력
> 

```python
df.loc[df['sepal_length'] > 5, ['sepal_length' , 'sepal_width']].head(5)
```

![alt text](/assets/img/image-29.png)

## 🏆 배운 내용 요약하기

---

1. **다음 멀티 인덱스 DataFrame** `df`**에서 그룹 'e'에 속하는 모든 행들 중에서 'b' 컬럼의 값만 선택하는 가장 올바른 코드는 무엇인가요? (단,** `df`**는 학습 노트에 제시된 멀티 인덱스 데이터프레임과 동일하다고 가정합니다.)**

- 답변

```python
df.loc['e'['b']
```

2. **다음 코드로 생성된 DataFrame** `df`**가 있을 때, 'a' 컬럼 값이 5이거나 ('a' == 5) 'c' 컬럼 값이 12인 행만 선택하는 코드로 올바른 것은 무엇인가요?**

```python
df = pd.DataFrame(
    {"a" : [4 ,5, 6],
    "b" : [7, 8, 9],
    "c" : [10, 11, 12]},
    index = [1, 2, 3])
```

- 답변

```python
df[(df['a'] == 5) | (df['c'] == 12)]
```

3. **학습 노트에서 제시된 멀티 인덱스 DataFrame** `df`**가 있다고 가정하고, 'c' 컬럼에 존재하는 **결측치(NaN)**의 총 개수를 계산하는 올바른 코드는 무엇인가요? ('c' 컬럼 값은 [10, 11, 12, np.nan, 12] 입니다.)**

- 답변

```python
df['c'].isnull().sum()
```
